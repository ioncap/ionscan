#!/bin/bash

# ==============================================================================
#  IONSCAN v23.0 - THE FRAMEWORK EDITION
# ==============================================================================
#
#  Main entry point for the IonScan framework.
#  This script sources libraries and modules, then starts the interactive shell.
#
# ==============================================================================

# --- SOURCE FRAMEWORK ---
INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../" && pwd)"

# Libraries
source "$INSTALL_DIR/lib/ui.sh"
source "$INSTALL_DIR/lib/core.sh"
source "$INSTALL_DIR/lib/network.sh"
source "$INSTALL_DIR/lib/database.sh" # New: Database library

# --- STATE VARIABLES ---
# Global variables are used to manage the state of the interactive shell.
# CURRENT_MODULE: The path of the currently loaded module (e.g., recon/fast_scan).
# MODULE_OPTIONS: An associative array holding the key-value pairs for the current module's options.
# TARGETS: An associative array storing the list of targets for scanning.
CURRENT_MODULE=""
declare -A MODULE_OPTIONS
declare -A TARGETS=([0]="demo.ionscan.org") # Add a demo target

# --- COMMAND HANDLERS ---
# Each 'cmd_*' function is responsible for handling a specific command entered
# by the user in the interactive shell.

cmd_help() {
    echo -e "${BOLD}IonScan Interactive Shell${NC}"
    echo "========================="
    echo "Core Commands:"
    echo "  help              Show this help message"
    echo "  show modules      List all available modules"
    echo "  show options      Show options for the current module"
    echo "  show targets      Show the current list of targets"
    echo "  add target <ip>   Add a target to the target list"
    echo "  rm target <id>    Remove a target from the list"
    echo "  use <module>      Select a module to use (e.g., 'use recon/fast_scan')"
    echo "  set <key> <val>   Set an option for the current module (e.g., 'set TARGET 192.168.1.1')"
    echo "  run               Run the current module"
    echo "  back              Deselect the current module"
    echo "  exit              Exit IonScan"
    echo ""
}

cmd_exit() {
    log_info "Exiting IonScan. Goodbye!"
    exit 0
}

cmd_show() {
    local sub_cmd="$1"
    case "$sub_cmd" in
        modules)
            echo -e "${BOLD}Available Modules:${NC}"
            echo "===================="
            
            local modules_dir="$INSTALL_DIR/modules"
            local files; files=$(find "$modules_dir" -type f -name "*.sh" | sort)
            
            for file in $files; do
                local category; category=$(basename "$file" .sh)
                local mods; mods=$(grep -oP '(?<=^mod_)[a-zA-Z0-9_]+' "$file")
                if [[ -n "$mods" ]]; then
                    echo -e "  ${CYAN}${category}${NC}:"
                    for mod in $mods;
                    do
                        echo "    - $category/$mod"
                    done
                fi
            done
            echo ""
            ;; 
        options)
            if [[ -z "$CURRENT_MODULE" ]]; then
                log_error "No module is currently loaded. Use 'use <module>' first."
                return
            fi
            
            echo -e "${BOLD}Module Options for: ${RED}${CURRENT_MODULE}${NC}"
            echo "================================================="
            
            local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//\//_}"
            options_array_name=${options_array_name^^}

            if ! declare -p "$options_array_name" &>/dev/null; then
                log_warning "Module has no configurable options."
                return
            fi

            declare -n ref_options_array="$options_array_name"
            
            printf "  %-15s %-15s %-10s %s\n" "Name" "Current Setting" "Required" "Description"
            printf "  %-15s %-15s %-10s %s\n" "----" "---------------" "--------" "-----------"
            
            for key in "${!ref_options_array[@]}"; do
                local option_details="${ref_options_array[$key]}"
                
                local description; description=$(echo "$option_details" | grep -o "description='[^']*'" | cut -d"'" -f2)
                local required; required=$(echo "$option_details" | grep -o "required=[^ ]*" | cut -d"=" -f2)
                local default_val; default_val=$(echo "$option_details" | grep -o "default='[^']*'" | cut -d"'" -f2)
                
                local current_val="${MODULE_OPTIONS[$key]:-$default_val}"
                
                printf "  %-15s %-15s %-10s %s\n" "$key" "$current_val" "$required" "$description"
            done
            echo ""
            ;; 
        targets)
            echo -e "${BOLD}Current Targets:${NC}"
            echo "================"
            if [[ ${#TARGETS[@]} -eq 0 ]]; then
                log_info "No targets have been added."
            else
                printf "  %-5s %s\n" "ID" "Target"
                printf "  %-5s %s\n" "---" "------"
                for id in "${!TARGETS[@]}"; do
                    printf "  %-5s %s\n" "$id" "${TARGETS[$id]}"
                done
            fi
            echo ""
            ;; 
        *)
            log_error "Unknown 'show' command: '$sub_cmd'. Try 'show modules', 'show options', or 'show targets'."
            ;; 
    esac
}

cmd_add_target() {
    local -n targets_ref="$1" # Nameref to the global TARGETS array
    local target_to_add="$2"
    if [[ -z "$target_to_add" ]]; then
        log_error "Usage: add target <ip/domain/cidr>"
        return
    fi
    local max_id=0
    for id in "${!targets_ref[@]}"; do
        if (( id > max_id )); then
            max_id=$id
        fi
    done
    local next_id=$(( max_id + 1 ))
    targets_ref[$next_id]="$target_to_add"
    log_success "Added target $next_id: $target_to_add"
}

cmd_rm_target() {
    local -n targets_ref="$1" # Nameref to the global TARGETS array
    local target_id_to_remove="$2"
    if [[ -z "$target_id_to_remove" ]]; then
        log_error "Usage: rm target <id>"
        return
    fi
    if [[ -v "targets_ref[$target_id_to_remove]" ]]; then
        log_info "Removed target $target_id_to_remove: ${targets_ref[$target_id_to_remove]}"
        unset "targets_ref[$target_id_to_remove]"
    else
        log_error "Invalid target ID: $target_id_to_remove"
    fi
}

cmd_use() {
    local module_name="$1"
    if ! [[ "$module_name" =~ ^[a-zA-Z0-9_]+/[a-zA-Z0-9_]+$ ]]; then
        log_error "Invalid module name format. Should be 'category/module'."
        return
    fi
    local module_category; module_category=$(echo "$module_name" | cut -d'/' -f1)
    local module_sub_name; module_sub_name=$(echo "$module_name" | cut -d'/' -f2)
    
    local module_path="$INSTALL_DIR/modules/${module_category}.sh"

    if [[ -f "$module_path" ]]; then
        source "$module_path"
        
        if ! command -v "mod_${module_sub_name}" >/dev/null 2>&1; then
            log_error "Sub-module '$module_sub_name' not found in '$module_category'."
            return
        fi
        
        CURRENT_MODULE="$module_name"
        MODULE_OPTIONS=() # Clear old options
        log_info "Module '$module_name' loaded."
        
        local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//\//_}"
        options_array_name=${options_array_name^^}

        if declare -p "$options_array_name" &>/dev/null; then
            declare -n ref_options_array="$options_array_name"
            for key in "${!ref_options_array[@]}"; do
                local option_details="${ref_options_array[$key]}"
                local default_val; default_val=$(echo "$option_details" | grep -o "default='[^']*'" | cut -d"'" -f2)
                if [[ -n "$default_val" ]]; then
                    MODULE_OPTIONS[$key]="$default_val"
                fi
            done
        fi
        
    else
        log_error "Module category '$module_category' not found."
    fi
}

cmd_back() {
    if [[ -n "$CURRENT_MODULE" ]]; then
        log_info "Unloaded module '$CURRENT_MODULE'."
        CURRENT_MODULE=""
        MODULE_OPTIONS=()
    else
        log_warning "No module is currently loaded."
    fi
}

cmd_set() {
    local args_line="$1"
    local key; key=$(echo "$args_line" | awk '{print $1}')
    local value; value=$(echo "$args_line" | cut -d' ' -f2-)
    
    # Alias RHOSTS to TARGET
    if [[ "$key" == "RHOSTS" ]]; then
        key="TARGET"
    fi

    if [[ -z "$CURRENT_MODULE" ]]; then
        log_error "No module loaded. Use 'use <module>' first."
        return
    fi
    
    local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//\//_}"
    options_array_name=${options_array_name^^}
    
    if ! declare -p "$options_array_name" &>/dev/null; then
        log_error "Module has no options to set."
        return
    fi
    
    declare -n ref_options_array="$options_array_name"
    
    if [[ -v "ref_options_array[$key]" ]]; then
        MODULE_OPTIONS[$key]="$value"
        log_info "$key => $value"
    else
        log_error "Unknown option for this module: '$key'"
    fi
}

cmd_run() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        log_error "No module loaded to run. Use 'use <module>' first."
        return
    fi
    
    local module_sub_name; module_sub_name=$(echo "$CURRENT_MODULE" | cut -d'/' -f2)
    local func_to_run="mod_${module_sub_name}"

    if command -v "$func_to_run" >/dev/null 2>&1; then
        local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//\//_}"
        options_array_name=${options_array_name^^}

        if declare -p "$options_array_name" &>/dev/null; then
            declare -n ref_options_array="$options_array_name"
            for key in "${!ref_options_array[@]}"; do
                local option_details="${ref_options_array[$key]}"
                local required; required=$(echo "$option_details" | grep -o "required=[^ ]*" | cut -d"=" -f2)
                
                if [[ "$required" == "true" ]]; then
                    if [[ -z "${MODULE_OPTIONS[$key]:-}" ]]; then
                        log_error "Required option '$key' for module '$CURRENT_MODULE' is not set."
                        log_info "Use 'show options' to see available options and 'set $key <value>' to set it."
                        return
                    fi
                fi
            done
        fi
        
        log_info "Running module: $CURRENT_MODULE..."
        eval "$func_to_run"
    else
        log_error "Cannot find run function '$func_to_run' for module '$CURRENT_MODULE'."
    fi
}

# --- INTERACTIVE SHELL ---
# This function implements the main loop for the interactive shell.
# It reads user input, parses it, and calls the appropriate command handler.
interactive_shell() {
    while true; do
        local prompt="ionscan"
        if [[ -n "$CURRENT_MODULE" ]]; then
            prompt="${prompt} (${CURRENT_MODULE})"
        fi
        prompt="${prompt} > "

        read -rp "$prompt" line

        if [[ -n "$line" ]]; then
            history -s "$line"
        fi

        local cmd; read -r cmd args <<< "$line"

        if [[ "$cmd" == "help" || "$cmd" == "?" ]]; then
            cmd_help
        elif [[ "$cmd" == "show" ]]; then
            cmd_show "$args"
        elif [[ "$cmd" == "add" && "$args" == "target "* ]]; then
            cmd_add_target "TARGETS" "${args#target }"
        elif [[ "$cmd" == "rm" && "$args" == "target "* ]]; then
            cmd_rm_target "TARGETS" "${args#target }"
        elif [[ "$cmd" == "use" ]]; then
            cmd_use "$args"
        elif [[ "$cmd" == "set" ]]; then
            cmd_set "$args"
        elif [[ "$cmd" == "run" ]]; then
            cmd_run
        elif [[ "$cmd" == "back" ]]; then
            cmd_back
        elif [[ "$cmd" == "exit" || "$cmd" == "quit" ]]; then
            cmd_exit
        elif [[ -z "$cmd" ]]; then
            # Empty command, do nothing
            :
        else
            log_error "Unknown command: '$cmd'. Type 'help' for a list of commands."
        fi
done
}


# --- SETUP FUNCTION ---
# This function checks for and installs missing dependencies.
# It is designed to be run with the --setup flag.
run_setup() {
    log_info "Running setup..."
    local missing_deps=()
    local deps_to_check=( "sqlite3" "nbtscan" )

    log_info "Checking for required dependencies..."
    for dep in "${deps_to_check[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            log_warning "Dependency '$dep' is not installed."
            missing_deps+=("$dep")
        else
            log_success "Dependency '$dep' is already installed."
        fi
    done

    if [ ${#missing_deps[@]} -eq 0 ]; then
        log_info "All dependencies are satisfied."
        exit 0
    fi

    echo -e "${YELLOW}The following dependencies are missing: ${missing_deps[*]}${NC}"
    read -rp "Do you want to install them? [y/N] " choice
    if [[ ! "$choice" =~ ^[Yy]$ ]]; then
        log_error "Installation aborted by user."
        exit 1
    fi

    log_info "Attempting to install missing dependencies..."
    if command -v apt-get &> /dev/null; then
        sudo apt-get update && sudo apt-get install -y "${missing_deps[@]}"
        if [ $? -eq 0 ]; then
            log_success "Dependencies installed successfully using apt-get."
        else
            log_error "Failed to install dependencies using apt-get."
            exit 1
        fi
    elif command -v yum &> /dev/null; then
        sudo yum install -y "${missing_deps[@]}"
        if [ $? -eq 0 ]; then
            log_success "Dependencies installed successfully using yum."
        else
            log_error "Failed to install dependencies using yum."
            exit 1
        fi
    else
        log_error "No supported package manager (apt-get, yum) found. Please install dependencies manually."
        exit 1
    fi

    log_info "Setup complete."
}
# --- MAIN ENTRY ---
# The main entry point of the script. It handles command-line arguments,
# initializes the framework, and decides whether to start the interactive shell
# or run in non-interactive mode.
main() {
    # Handle command-line arguments
    # We use a loop to handle multiple flags, e.g., --agree --auto
    local remaining_args=()
    local auto_run=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --setup)
                run_setup
                exit 0
                ;;
            --agree)
                export AGREED="true"
                shift
                ;;
            --help)
                show_help # from core.sh
                exit 0
                ;;
            --auto)
                auto_run=true
                shift
                ;;
            *)
                # Not a flag we handle here, could be for non-interactive mode
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    # Restore non-flag arguments
    set -- "${remaining_args[@]}"

    if [[ "$auto_run" == "true" ]]; then
        # If --auto is passed, prepend a comprehensive scan sequence.
        get_interface # Sets MY_IP
        local local_subnet
        local_subnet=$(echo "$MY_IP" | cut -d'.' -f1-3).0/24
        set -- "use" "recon/fast_scan" "set" "TARGET" "$local_subnet" "run" \
               "use" "exploit/advanced_vuln" "set" "TARGET" "$local_subnet" "run" \
               "use" "report/report" "set" "AUTO_OPEN" "true" "run" "$@"
    fi

    setup_config
    db_init # Initialize the database at the start

    # Check and fix log directory permissions
    if [ -d "$LOG_DIR" ] && [ ! -w "$LOG_DIR" ]; then
        local owner="${SUDO_USER:-$(whoami)}"
        log_warning "Log directory not writable. Attempting to fix with 'sudo chown'..."
        sudo chown -R "$owner" "$LOG_DIR"
        if [ ! -w "$LOG_DIR" ]; then
            log_error "Failed to set correct permissions on $LOG_DIR. Please fix it manually."
            exit 1
        fi
    fi

    # If after parsing flags, no other arguments remain, start interactive shell
    if [[ $# -eq 0 ]]; then
        header # Display header once on start
        # Disclaimer check
        if [[ "${AGREED:-}" != "true" ]]; then
            echo -e "${RED}${BOLD}DISCLAIMER${NC}"
            echo "This tool is for educational and authorized use only."
            read -rp "Do you agree? [y/N] " A
            if [[ ! "$A" =~ ^[Yy]$ ]]; then exit 1; fi
        fi
        interactive_shell
    else
        # Non-interactive mode
        header
        if [[ "${AGREED:-}" != "true" ]]; then
            log_error "DISCLAIMER: This tool is for educational and authorized use only."
            log_error "Run with the --agree flag to accept the terms."
            exit 1
        fi

        local commands_to_run=("$@")
        local i=0
        while [[ $i -lt ${#commands_to_run[@]} ]]; do
            local cmd="${commands_to_run[$i]}"
            i=$((i + 1))
            
            case "$cmd" in
                use)
                    local module="${commands_to_run[$i]}"
                    cmd_use "$module"
                    i=$((i + 1))
                    ;;
                set)
                    local key="${commands_to_run[$i]}"
                    i=$((i + 1))
                    # Collect all parts of the value until the next command
                    local value=""
                    while [[ $i -lt ${#commands_to_run[@]} ]] && ! [[ "${commands_to_run[$i]}" =~ ^(use|set|run|add|rm|show|back|exit)$ ]]; do
                        if [[ -n "$value" ]]; then
                            value+=" "
                        fi
                        value+="${commands_to_run[$i]}"
                        i=$((i+1))
                    done
                    cmd_set "$key $value"
                    ;;
                run)
                    cmd_run
                    ;;
                add)
                    if [[ "${commands_to_run[$i]}" == "target" ]]; then
                        i=$((i+1))
                        local target_val="${commands_to_run[$i]}"
                        i=$((i+1))
                        cmd_add_target "TARGETS" "$target_val"
                    else
                        log_error "Unknown add command in non-interactive mode."
                    fi
                    ;;
                rm)
                    if [[ "${commands_to_run[$i]}" == "target" ]]; then
                        i=$((i+1))
                        local target_id="${commands_to_run[$i]}"
                        i=$((i+1))
                        cmd_rm_target "TARGETS" "$target_id"
                    else
                        log_error "Unknown rm command in non-interactive mode."
                    fi
                    ;;
                show)
                    local sub_cmd="${commands_to_run[$i]}"
                    i=$((i+1))
                    cmd_show "$sub_cmd"
                    ;;
                back)
                    cmd_back
                    ;;
                exit|quit)
                    cmd_exit
                    ;;
                *)
                    log_error "Unknown command in non-interactive mode: $cmd"
                    # To prevent infinite loops on unknown commands, we stop processing.
                    break
                    ;;
            esac
        done
    fi
}

main "$@"
