#!/usr/bin/env bash

# ==============================================================================
#  IONSCAN v23.0 - THE FRAMEWORK EDITION
# ==============================================================================
#
#  Main entry point for the IonScan framework.
#  This script sources libraries and modules, then starts the interactive shell.
#
# ==============================================================================

# --- SOURCE FRAMEWORK ---
INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../" && pwd)"

# Libraries
source "$INSTALL_DIR/lib/ui.sh"
source "$INSTALL_DIR/lib/core.sh"
source "$INSTALL_DIR/lib/network.sh"

# --- STATE VARIABLES ---
# Global variables to manage the shell's state
CURRENT_MODULE=""
declare -A MODULE_OPTIONS

# --- COMMAND HANDLERS ---

cmd_help() {
    echo -e "${BOLD}IonScan Interactive Shell${NC}"
    echo "========================="
    echo "Core Commands:"
    echo "  help              Show this help message"
    echo "  show modules      List all available modules"
    echo "  use <module>      Select a module to use (e.g., 'use recon/fast_scan')"
    echo "  show options      Show options for the current module"
    echo "  set <key> <val>   Set an option for the current module (e.g., 'set TARGET 192.168.1.1')"
    echo "  run               Run the current module"
    echo "  back              Deselect the current module"
    echo "  exit              Exit IonScan"
    echo ""
}

cmd_exit() {
    log_info "Exiting IonScan. Goodbye!"
    exit 0
}

cmd_show() {
    local sub_cmd="$1"
    case "$sub_cmd" in
        modules)
            echo -e "${BOLD}Available Modules:${NC}"
            echo "===================="
            
            local modules_dir="$INSTALL_DIR/modules"
            local files; files=$(find "$modules_dir" -type f -name "*.sh" | sort)
            
            for file in $files; do
                local category; category=$(basename "$file" .sh)
                # Find all mod_* functions in the file
                local mods; mods=$(grep -oP '(?<=^mod_)[a-zA-Z0-9_]+' "$file")
                if [[ -n "$mods" ]]; then
                    echo -e "  ${CYAN}${category}${NC}:"
                    for mod in $mods; do
                        echo "    - $category/$mod"
                    done
                fi
            done
            echo ""
            ;; 
        options)
            if [[ -z "$CURRENT_MODULE" ]]; then
                log_error "No module is currently loaded. Use 'use <module>' first."
                return
            fi
            
            echo -e "${BOLD}Module Options for: ${RED}${CURRENT_MODULE}${NC}"
            echo "================================================="
            
            local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//	kinter_/_}"
            options_array_name=${options_array_name^^}

            if ! declare -p "$options_array_name" &>/dev/null; then
                log_warning "Module has no configurable options."
                return
            fi

            local keys_str; keys_str=$(eval echo "\
${!$options_array_name[@]}" )
            
            printf "  %-15s %-15s %-10s %s\n" "Name" "Current Setting" "Required" "Description"
            printf "  %-15s %-15s %-10s %s\n" "----" "---------------" "--------" "-----------" 
            
            for key in $keys_str;
 do
                local option_details; option_details=$(eval echo "\
${$options_array_name[$key]}" )
                
                local description; description=$(echo "$option_details" | grep -o "description='[^']*'" | cut -d'\' -f2)
                local required; required=$(echo "$option_details" | grep -o "required=[^ ]*" | cut -d'=' -f2)
                local default_val; default_val=$(echo "$option_details" | grep -o "default='[^']*'" | cut -d'\' -f2)
                
                local current_val="${MODULE_OPTIONS[$key]:-$default_val}"
                
                printf "  %-15s %-15s %-10s %s\n" "$key" "$current_val" "$required" "$description"
            done
            echo ""
            ;; 
        *)
            log_error "Unknown 'show' command: '$sub_cmd'. Try 'show modules' or 'show options'."
            ;;    esac
}

cmd_use() {
    local module_name="$1"
    local module_category; module_category=$(echo "$module_name" | cut -d'/' -f1)
    local module_sub_name; module_sub_name=$(echo "$module_name" | cut -d'/' -f2)
    
    local module_path="$INSTALL_DIR/modules/${module_category}.sh"

    if [[ -f "$module_path" ]]; then
        source "$module_path"
        
        # Check if the mod_ function exists
        if ! command -v "mod_${module_sub_name}" >/dev/null 2>&1;
 then
            log_error "Sub-module '$module_sub_name' not found in '$module_category'."
            return
        fi
        
        CURRENT_MODULE="$module_name"
        MODULE_OPTIONS=() # Clear old options
        log_info "Module '$module_name' loaded."
        
        # Pre-load default options
        local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//	kinter_/_}"
        options_array_name=${options_array_name^^}

        if declare -p "$options_array_name" &>/dev/null;
 then
            local keys_str; keys_str=$(eval echo "\
${!$options_array_name[@]}" )
            for key in $keys_str;
 do
                local option_details; option_details=$(eval echo "\
${$options_array_name[$key]}" )
                local default_val; default_val=$(echo "$option_details" | grep -o "default='[^']*'" | cut -d'\' -f2)
                if [[ -n "$default_val" ]]; then
                    MODULE_OPTIONS[$key]="$default_val"
                fi
            done
        fi
        
    else
        log_error "Module category '$module_category' not found."
    fi
}

cmd_back() {
    if [[ -n "$CURRENT_MODULE" ]]; then
        log_info "Unloaded module '$CURRENT_MODULE'."
        CURRENT_MODULE=""
        MODULE_OPTIONS=()
    else
        log_warning "No module is currently loaded."
    fi
}

cmd_set() {
    local key="$1"
    local value="$2"
    
    if [[ -z "$CURRENT_MODULE" ]]; then
        log_error "No module loaded. Use 'use <module>' first."
        return
    fi
    
    local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//	kinter_/_}"
    options_array_name=${options_array_name^^}
    
    if ! declare -p "$options_array_name" &>/dev/null;
 then
        log_error "Module has no options to set."
        return
    fi
    
    local keys_str; keys_str=$(eval echo "\
${!$options_array_name[@]}" )
    
    if [[ " ${keys_str[*]} " =~ " $key " ]]; then
        MODULE_OPTIONS[$key]="$value"
        log_info "$key => $value"
    else
        log_error "Unknown option for this module: '$key'"
    fi
}

cmd_run() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        log_error "No module loaded to run. Use 'use <module>' first."
        return
    fi
    
    local module_sub_name; module_sub_name=$(echo "$CURRENT_MODULE" | cut -d'/' -f2)
    local func_to_run="mod_${module_sub_name}"

    if command -v "$func_to_run" >/dev/null 2>&1;
 then
        # Before running, check for required options
        # ... (to be implemented)
        
        log_info "Running module: $CURRENT_MODULE..."
        eval "$func_to_run"
    else
        log_error "Cannot find run function '$func_to_run' for module '$CURRENT_MODULE'."
    fi
}

# --- INTERACTIVE SHELL ---
interactive_shell() {
    while true;
 do
        local prompt="ionscan"
        if [[ -n "$CURRENT_MODULE" ]]; then
            prompt="${prompt} (${CURRENT_MODULE})"
        fi
        prompt="${prompt} > "

        read -rp "$prompt" line

        if [[ -n "$line" ]]; then
            history -s "$line"
        fi

        local cmd; read -r cmd args <<< "$line"

        case "$cmd" in
            help|?)
                cmd_help
                ;; 
            show)
                cmd_show "$args"
                ;; 
            use)
                cmd_use "$args"
                ;; 
            set)
                local key; local value; read -r key value <<< "$args"
                cmd_set "$key" "$value"
                ;; 
            run)
                cmd_run
                ;; 
            back)
                cmd_back
                ;; 
            exit|quit)
                cmd_exit
                ;; 
            *)
                log_error "Unknown command: '$cmd'. Type 'help' for a list of commands."
                ;; 
        esac
    done
}


# --- MAIN ENTRY ---
main() {
    setup_config

    if [[ $# -eq 0 ]]; then
        header # Display header once on start
        # Disclaimer check
        if [[ "${AGREED:-}" != "true" ]]; then
            echo -e "${RED}${BOLD}DISCLAIMER${NC}"
            echo "This tool is for educational and authorized use only."
            read -rp "Do you agree? [y/N] " A
            if [[ ! "$A" =~ ^[Yy]$ ]]; then exit 1; fi
        fi
        interactive_shell
    fi

    # Handle non-interactive command-line arguments (re-integration)
}

main "$@"
