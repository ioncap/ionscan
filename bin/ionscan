#!/usr/bin/env bash

# ==============================================================================
#  IONSCAN v23.0 - THE FRAMEWORK EDITION
# ==============================================================================
#
#  Main entry point for the IonScan framework.
#  This script sources libraries and modules, then starts the interactive shell.
#
# ==============================================================================

# --- SOURCE FRAMEWORK ---
INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../" && pwd)"

# Libraries
source "$INSTALL_DIR/lib/ui.sh"
source "$INSTALL_DIR/lib/core.sh"
source "$INSTALL_DIR/lib/network.sh"
source "$INSTALL_DIR/lib/database.sh" # New: Database library

# --- STATE VARIABLES ---
# Global variables to manage the shell's state
CURRENT_MODULE=""
declare -A MODULE_OPTIONS
declare -A TARGETS # New: For target management

# --- COMMAND HANDLERS ---

cmd_help() {
    echo -e "${BOLD}IonScan Interactive Shell${NC}"
    echo "========================="
    echo "Core Commands:"
    echo "  help              Show this help message"
    echo "  show modules      List all available modules"
    echo "  show options      Show options for the current module"
    echo "  show targets      Show the current list of targets"
    echo "  add target <ip>   Add a target to the target list"
    echo "  rm target <id>    Remove a target from the list"
    echo "  use <module>      Select a module to use (e.g., 'use recon/fast_scan')"
    echo "  set <key> <val>   Set an option for the current module (e.g., 'set TARGET 192.168.1.1')"
    echo "  run               Run the current module"
    echo "  back              Deselect the current module"
    echo "  exit              Exit IonScan"
    echo ""
}

cmd_exit() {
    log_info "Exiting IonScan. Goodbye!"
    exit 0
}

cmd_show() {
    local sub_cmd="$1"
    case "$sub_cmd" in
        modules)
            echo -e "${BOLD}Available Modules:${NC}"
            echo "===================="
            
            local modules_dir="$INSTALL_DIR/modules"
            local files; files=$(find "$modules_dir" -type f -name "*.sh" | sort)
            
            for file in $files; do
                local category; category=$(basename "$file" .sh)
                local mods; mods=$(grep -oP '(?<=^mod_)[a-zA-Z0-9_]+' "$file")
                if [[ -n "$mods" ]]; then
                    echo -e "  ${CYAN}${category}${NC}:"
                    for mod in $mods;
                    do
                        echo "    - $category/$mod"
                    done
                fi
            done
            echo ""
            ;; 
        options)
            if [[ -z "$CURRENT_MODULE" ]]; then
                log_error "No module is currently loaded. Use 'use <module>' first."
                return
            fi
            
            echo -e "${BOLD}Module Options for: ${RED}${CURRENT_MODULE}${NC}"
            echo "================================================="
            
            local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//ash/ash}"
            options_array_name=${options_array_name^^}

            if ! declare -p "$options_array_name" &>/dev/null; then
                log_warning "Module has no configurable options."
                return
            fi

            declare -n ref_options_array="$options_array_name"
            
            printf "  %-15s %-15s %-10s %s\n" "Name" "Current Setting" "Required" "Description"
            printf "  %-15s %-15s %-10s %s\n" "----" "---------------" "--------" "-----------"
            
            for key in "${!ref_options_array[@]}"; do
                local option_details="${ref_options_array[$key]}"
                
                local description; description=$(echo "$option_details" | grep -o "description='[^']*'" | cut -d"'" -f2)
                local required; required=$(echo "$option_details" | grep -o "required=[^ ]*" | cut -d"=" -f2)
                local default_val; default_val=$(echo "$option_details" | grep -o "default='[^']*'" | cut -d"'" -f2)
                
                local current_val="${MODULE_OPTIONS[$key]:-$default_val}"
                
                printf "  %-15s %-15s %-10s %s\n" "$key" "$current_val" "$required" "$description"
            done
            echo ""
            ;; 
        targets)
            echo -e "${BOLD}Current Targets:${NC}"
            echo "================"
            if [[ ${#TARGETS[@]} -eq 0 ]]; then
                log_info "No targets have been added."
            else
                printf "  %-5s %s\n" "ID" "Target"
                printf "  %-5s %s\n" "---" "------"
                for id in "${!TARGETS[@]}"; do
                    printf "  %-5s %s\n" "$id" "${TARGETS[$id]}"
                done
            fi
            echo ""
            ;; 
        *)
            log_error "Unknown 'show' command: '$sub_cmd'. Try 'show modules', 'show options', or 'show targets'."
            ;; 
    esac
}

cmd_add_target() {
    local target_to_add="$1"
    if [[ -z "$target_to_add" ]]; then
        log_error "Usage: add target <ip/domain/cidr>"
        return
    fi
    local next_id=$(( ${#TARGETS[@]} + 1 ))
    TARGETS[$next_id]="$target_to_add"
    log_success "Added target $next_id: $target_to_add"
}

cmd_rm_target() {
    local target_id_to_remove="$1"
    if [[ -z "$target_id_to_remove" ]]; then
        log_error "Usage: rm target <id>"
        return
    fi
    if [[ -v "TARGETS[$target_id_to_remove]" ]]; then
        log_info "Removed target $target_id_to_remove: ${TARGETS[$target_id_to_remove]}"
        unset "TARGETS[$target_id_to_remove]"
    else
        log_error "Invalid target ID: $target_id_to_remove"
    fi
}

cmd_use() {
    local module_name="$1"
    local module_category; module_category=$(echo "$module_name" | cut -d'/' -f1)
    local module_sub_name; module_sub_name=$(echo "$module_name" | cut -d'/' -f2)
    
    local module_path="$INSTALL_DIR/modules/${module_category}.sh"

    if [[ -f "$module_path" ]]; then
        source "$module_path"
        
        if ! command -v "mod_${module_sub_name}" >/dev/null 2>&1; then
            log_error "Sub-module '$module_sub_name' not found in '$module_category'."
            return
        fi
        
        CURRENT_MODULE="$module_name"
        MODULE_OPTIONS=() # Clear old options
        log_info "Module '$module_name' loaded."
        
        local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//ash/ash}"
        options_array_name=${options_array_name^^}

        if declare -p "$options_array_name" &>/dev/null; then
            declare -n ref_options_array="$options_array_name"
            for key in "${!ref_options_array[@]}"; do
                local option_details="${ref_options_array[$key]}"
                local default_val; default_val=$(echo "$option_details" | grep -o "default='[^']*'" | cut -d"'" -f2)
                if [[ -n "$default_val" ]]; then
                    MODULE_OPTIONS[$key]="$default_val"
                fi
            done
        fi
        
    else
        log_error "Module category '$module_category' not found."
    fi
}

cmd_back() {
    if [[ -n "$CURRENT_MODULE" ]]; then
        log_info "Unloaded module '$CURRENT_MODULE'."
        CURRENT_MODULE=""
        MODULE_OPTIONS=()
    else
        log_warning "No module is currently loaded."
    fi
}

cmd_set() {
    local key="$1"
    local value="$2"
    
    # Alias RHOSTS to TARGET
    if [[ "$key" == "RHOSTS" ]]; then
        key="TARGET"
    fi

    if [[ -z "$CURRENT_MODULE" ]]; then
        log_error "No module loaded. Use 'use <module>' first."
        return
    fi
    
    local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//ash/ash}"
    options_array_name=${options_array_name^^}
    
    if ! declare -p "$options_array_name" &>/dev/null; then
        log_error "Module has no options to set."
        return
    fi
    
    declare -n ref_options_array="$options_array_name"
    
    if [[ -v "ref_options_array[$key]" ]]; then
        MODULE_OPTIONS[$key]="$value"
        log_info "$key => $value"
    else
        log_error "Unknown option for this module: '$key'"
    fi
}

cmd_run() {
    if [[ -z "$CURRENT_MODULE" ]]; then
        log_error "No module loaded to run. Use 'use <module>' first."
        return
    fi
    
    local module_sub_name; module_sub_name=$(echo "$CURRENT_MODULE" | cut -d'/' -f2)
    local func_to_run="mod_${module_sub_name}"

    if command -v "$func_to_run" >/dev/null 2>&1; then
        local options_array_name="MOD_OPTIONS_${CURRENT_MODULE//ash/ash}"
        options_array_name=${options_array_name^^}

        if declare -p "$options_array_name" &>/dev/null; then
            declare -n ref_options_array="$options_array_name"
            for key in "${!ref_options_array[@]}"; do
                local option_details="${ref_options_array[$key]}"
                local required; required=$(echo "$option_details" | grep -o "required=[^ ]*" | cut -d"=" -f2)
                
                if [[ "$required" == "true" ]]; then
                    if [[ -z "${MODULE_OPTIONS[$key]}" ]]; then
                        log_error "Required option '$key' for module '$CURRENT_MODULE' is not set."
                        log_info "Use 'show options' to see available options and 'set $key <value>' to set it."
                        return
                    fi
                fi
            done
        fi
        
        log_info "Running module: $CURRENT_MODULE..."
        eval "$func_to_run"
    else
        log_error "Cannot find run function '$func_to_run' for module '$CURRENT_MODULE'."
    fi
}

# --- INTERACTIVE SHELL ---
interactive_shell() {
    while true; do
        local prompt="ionscan"
        if [[ -n "$CURRENT_MODULE" ]]; then
            prompt="${prompt} (${CURRENT_MODULE})"
        fi
        prompt="${prompt} > "

        read -rp "$prompt" line

        if [[ -n "$line" ]]; then
            history -s "$line"
        fi

        local cmd; read -r cmd args <<< "$line"

        if [[ "$cmd" == "help" || "$cmd" == "?" ]]; then
            cmd_help
        elif [[ "$cmd" == "show" ]]; then
            cmd_show "$args"
        elif [[ "$cmd" == "add" && "$args" == "target "* ]]; then
            cmd_add_target "${args#target }"
        elif [[ "$cmd" == "rm" && "$args" == "target "* ]]; then
            cmd_rm_target "${args#target }"
        elif [[ "$cmd" == "use" ]]; then
            cmd_use "$args"
        elif [[ "$cmd" == "set" ]]; then
            local key; local value; read -r key value <<< "$args"
            cmd_set "$key" "$value"
        elif [[ "$cmd" == "run" ]]; then
            cmd_run
        elif [[ "$cmd" == "back" ]]; then
            cmd_back
        elif [[ "$cmd" == "exit" || "$cmd" == "quit" ]]; then
            cmd_exit
        elif [[ -z "$cmd" ]]; then
            # Empty command, do nothing
            :
        else
            log_error "Unknown command: '$cmd'. Type 'help' for a list of commands."
        fi
done
}


# --- MAIN ENTRY ---
main() {
    setup_config
    db_init # Initialize the database at the start

    if [[ $# -eq 0 ]]; then
        header # Display header once on start
        # Disclaimer check
        if [[ "${AGREED:-}" != "true" ]]; then
            echo -e "${RED}${BOLD}DISCLAIMER${NC}"
            echo "This tool is for educational and authorized use only."
            read -rp "Do you agree? [y/N] " A
            if [[ ! "$A" =~ ^[Yy]$ ]]; then exit 1; fi
        fi
        interactive_shell
    fi

    # Handle non-interactive command-line arguments (re-integration)
}

main "$@"
